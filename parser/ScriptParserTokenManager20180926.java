package net.hiwii.system.parser;
/* Generated By:JavaCC: Do not edit this line. ScriptParserTokenManager.java */

/** Token Manager. */
public class ScriptParserTokenManager implements ScriptParserConstants
{

	/** Debug output. */
	public  java.io.PrintStream debugStream = System.out;
	/** Set debug output. */
	public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
	private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
	{
		switch (pos)
		{
		case 0:
			if ((active0 & 0x800000000140L) != 0L)
				return 2;
			return -1;
		case 1:
			if ((active0 & 0x100L) != 0L)
				return 0;
			return -1;
		default :
			return -1;
		}
	}
	private final int jjStartNfa_0(int pos, long active0, long active1)
	{
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
	}
	private int jjStopAtPos(int pos, int kind)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}
	private int jjMoveStringLiteralDfa0_0()
	{
		switch(curChar)
		{
		case 9:
			return jjStopAtPos(0, 2);
		case 10:
			return jjStopAtPos(0, 3);
		case 12:
			return jjStopAtPos(0, 5);
		case 13:
			return jjStopAtPos(0, 4);
		case 32:
			return jjStopAtPos(0, 1);
		case 33:
			jjmatchedKind = 40;
			return jjMoveStringLiteralDfa1_0(0x200000000000000L, 0x10L);
		case 35:
			jjmatchedKind = 37;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L);
		case 36:
			jjmatchedKind = 36;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L);
		case 37:
			jjmatchedKind = 52;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x100L);
		case 38:
			jjmatchedKind = 49;
			return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);
		case 40:
			return jjStopAtPos(0, 26);
		case 41:
			return jjStopAtPos(0, 27);
		case 42:
			return jjStopAtPos(0, 46);
		case 43:
			jjmatchedKind = 44;
			return jjMoveStringLiteralDfa1_0(0x4000000000000000L, 0x20L);
		case 44:
			return jjStopAtPos(0, 33);
		case 45:
			jjmatchedKind = 45;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x42L);
		case 46:
			jjmatchedKind = 34;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x400L);
		case 47:
			jjmatchedKind = 47;
			return jjMoveStringLiteralDfa1_0(0x140L, 0x0L);
		case 58:
			jjmatchedKind = 43;
			return jjMoveStringLiteralDfa1_0(0x0L, 0xc000L);
		case 59:
			return jjStopAtPos(0, 32);
		case 60:
			jjmatchedKind = 39;
			return jjMoveStringLiteralDfa1_0(0x9080000000000000L, 0xdL);
		case 61:
			jjmatchedKind = 38;
			return jjMoveStringLiteralDfa1_0(0x40000000000000L, 0x800L);
		case 62:
			jjmatchedKind = 53;
			return jjMoveStringLiteralDfa1_0(0x2100000000000000L, 0x0L);
		case 63:
			return jjStopAtPos(0, 42);
		case 64:
			return jjStopAtPos(0, 35);
		case 91:
			return jjStopAtPos(0, 30);
		case 92:
			return jjStopAtPos(0, 48);
		case 93:
			return jjStopAtPos(0, 31);
		case 94:
			jjmatchedKind = 51;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x80L);
		case 123:
			return jjStopAtPos(0, 28);
		case 124:
			jjmatchedKind = 50;
			return jjMoveStringLiteralDfa1_0(0x400000000000000L, 0x0L);
		case 125:
			return jjStopAtPos(0, 29);
		case 126:
			jjmatchedKind = 41;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
		default :
			return jjMoveNfa_0(3, 0);
		}
	}
	private int jjMoveStringLiteralDfa1_0(long active0, long active1)
	{
		try { curChar = input_stream.readChar(); }
		catch(java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0, active1);
			return 1;
		}
		switch(curChar)
		{
		case 33:
			if ((active1 & 0x8L) != 0L)
				return jjStopAtPos(1, 67);
			else if ((active1 & 0x1000L) != 0L)
				return jjStopAtPos(1, 76);
			break;
		case 38:
			if ((active0 & 0x800000000000000L) != 0L)
				return jjStopAtPos(1, 59);
			break;
		case 42:
			if ((active0 & 0x100L) != 0L)
				return jjStartNfaWithStates_0(1, 8, 0);
			break;
		case 43:
			if ((active0 & 0x8000000000000000L) != 0L)
				return jjStopAtPos(1, 63);
			break;
		case 45:
			if ((active1 & 0x4L) != 0L)
				return jjStopAtPos(1, 66);
			break;
		case 46:
			return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L);
		case 47:
			if ((active0 & 0x40L) != 0L)
				return jjStopAtPos(1, 6);
			break;
		case 58:
			if ((active1 & 0x8000L) != 0L)
				return jjStopAtPos(1, 79);
			break;
		case 60:
			if ((active0 & 0x1000000000000000L) != 0L)
				return jjStopAtPos(1, 60);
			break;
		case 61:
			if ((active0 & 0x40000000000000L) != 0L)
				return jjStopAtPos(1, 54);
			else if ((active0 & 0x80000000000000L) != 0L)
				return jjStopAtPos(1, 55);
			else if ((active0 & 0x100000000000000L) != 0L)
				return jjStopAtPos(1, 56);
			else if ((active0 & 0x200000000000000L) != 0L)
				return jjStopAtPos(1, 57);
			else if ((active1 & 0x20L) != 0L)
				return jjStopAtPos(1, 69);
			else if ((active1 & 0x40L) != 0L)
				return jjStopAtPos(1, 70);
			else if ((active1 & 0x80L) != 0L)
				return jjStopAtPos(1, 71);
			else if ((active1 & 0x100L) != 0L)
				return jjStopAtPos(1, 72);
			else if ((active1 & 0x200L) != 0L)
				return jjStopAtPos(1, 73);
			else if ((active1 & 0x4000L) != 0L)
				return jjStopAtPos(1, 78);
			break;
		case 62:
			if ((active0 & 0x2000000000000000L) != 0L)
				return jjStopAtPos(1, 61);
			else if ((active0 & 0x4000000000000000L) != 0L)
				return jjStopAtPos(1, 62);
			else if ((active1 & 0x1L) != 0L)
				return jjStopAtPos(1, 64);
			else if ((active1 & 0x2L) != 0L)
				return jjStopAtPos(1, 65);
			else if ((active1 & 0x10L) != 0L)
				return jjStopAtPos(1, 68);
			else if ((active1 & 0x800L) != 0L)
				return jjStopAtPos(1, 75);
			break;
		case 124:
			if ((active0 & 0x400000000000000L) != 0L)
				return jjStopAtPos(1, 58);
			break;
		case 126:
			if ((active1 & 0x2000L) != 0L)
				return jjStopAtPos(1, 77);
			break;
		default :
			break;
		}
		return jjStartNfa_0(0, active0, active1);
	}
	private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
	{
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(0, old0, old1);
		try { curChar = input_stream.readChar(); }
		catch(java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, 0L, active1);
			return 2;
		}
		switch(curChar)
		{
		case 46:
			if ((active1 & 0x400L) != 0L)
				return jjStopAtPos(2, 74);
			break;
		default :
			break;
		}
		return jjStartNfa_0(1, 0L, active1);
	}
	private int jjStartNfaWithStates_0(int pos, int kind, int state)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try { curChar = input_stream.readChar(); }
		catch(java.io.IOException e) { return pos + 1; }
		return jjMoveNfa_0(state, pos + 1);
	}
	static final long[] jjbitVec0 = {
		0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
	};
	static final long[] jjbitVec2 = {
		0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
	};
	static final long[] jjbitVec3 = {
		0xfff0000000200002L, 0xffffffffffffdfffL, 0xfffff00f7fffffffL, 0x12000000007fffffL
	};
	static final long[] jjbitVec4 = {
		0x0L, 0x0L, 0x420043c00000000L, 0xff7fffffff7fffffL
	};
	static final long[] jjbitVec5 = {
		0xffffcffffffffL, 0xffffffffffff0000L, 0xf9ff3fffffffffffL, 0x401f00030003L
	};
	static final long[] jjbitVec6 = {
		0x0L, 0x400000000000000L, 0xfffffffbffffd740L, 0xffffffcff7fffL
	};
	static final long[] jjbitVec7 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff003L, 0x33fffffffff199fL
	};
	static final long[] jjbitVec8 = {
		0xfffe000000000000L, 0xfffffffe027fffffL, 0xffL, 0x707ffffff0000L
	};
	static final long[] jjbitVec9 = {
		0x7fffffe00000000L, 0xfffe0000000007ffL, 0xffffffffffffffffL, 0x1c000060002fffffL
	};
	static final long[] jjbitVec10 = {
		0x1ffffffd0000L, 0x0L, 0x3fffffffffL, 0x0L
	};
	static final long[] jjbitVec11 = {
		0x23ffffffffffffe0L, 0x3ff010000L, 0x3c5fdfffff99fe0L, 0xf0003b0000000L
	};
	static final long[] jjbitVec12 = {
		0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100010000L
	};
	static final long[] jjbitVec13 = {
		0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L
	};
	static final long[] jjbitVec14 = {
		0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L
	};
	static final long[] jjbitVec15 = {
		0x3fffdfffffddfe0L, 0x300000000L, 0x2ffbfffffc7fffe0L, 0x7fL
	};
	static final long[] jjbitVec16 = {
		0x800dfffffffffffeL, 0x7fL, 0x200decaefef02596L, 0x3000005fL
	};
	static final long[] jjbitVec17 = {
		0x1L, 0x7fffffffeffL, 0xf00L, 0x0L
	};
	static final long[] jjbitVec18 = {
		0x6fbffffffffL, 0x3f0000L, 0xffffffff00000000L, 0x7fffffffff003fL
	};
	static final long[] jjbitVec19 = {
		0xffffffffffffffffL, 0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL
	};
	static final long[] jjbitVec20 = {
		0xffffffffffffff7fL, 0xffffffff3d7f3d7fL, 0x7f3d7fffffff3d7fL, 0xffff7fffff7f7f3dL
	};
	static final long[] jjbitVec21 = {
		0xffffffff7f3d7fffL, 0x7ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
	};
	static final long[] jjbitVec22 = {
		0xffffffffffffffffL, 0x7f9fffffffffffL, 0xffffffff07fffffeL, 0x7ffffffffffL
	};
	static final long[] jjbitVec23 = {
		0x0L, 0x0L, 0xfffffffffffffL, 0x8000000L
	};
	static final long[] jjbitVec24 = {
		0xffffffff00000000L, 0xffffffffffffffL, 0x1ffffffffffL, 0x0L
	};
	static final long[] jjbitVec25 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL
	};
	static final long[] jjbitVec26 = {
		0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL
	};
	static final long[] jjbitVec27 = {
		0x8000000000000000L, 0x8000000000000001L, 0xffff00000000L, 0x0L
	};
	static final long[] jjbitVec28 = {
		0x3fbbd503e2ffc84L, 0xffffffff00000000L, 0xfL, 0x0L
	};
	static final long[] jjbitVec29 = {
		0x73e03fe000000e0L, 0xfffffffffffffffeL, 0xfffffffe601fffffL, 0x7fffffffffffffffL
	};
	static final long[] jjbitVec30 = {
		0xfffe1fffffffffe0L, 0xffffffffffffffffL, 0xffffff00007fffL, 0x0L
	};
	static final long[] jjbitVec31 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffL, 0x0L
	};
	static final long[] jjbitVec32 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L
	};
	static final long[] jjbitVec33 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0x1fffL, 0x0L
	};
	static final long[] jjbitVec34 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L
	};
	static final long[] jjbitVec35 = {
		0x3fffffffffffL, 0x0L, 0x0L, 0x0L
	};
	static final long[] jjbitVec36 = {
		0x5f7ffdffa0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
	};
	static final long[] jjbitVec37 = {
		0x3fffffffffffffffL, 0xffffffffffff0000L, 0xfffffffffffcffffL, 0xfff0000000000ffL
	};
	static final long[] jjbitVec38 = {
		0x18000000000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x1fffffffffffffffL
	};
	static final long[] jjbitVec39 = {
		0x87fffffe00000010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0x631cfcfcfcL
	};
	static final long[] jjbitVec40 = {
		0x0L, 0x0L, 0x420043cffffffffL, 0xff7fffffff7fffffL
	};
	static final long[] jjbitVec41 = {
		0xffffffffffffffffL, 0x400000700007fffL, 0xfffffffbffffd740L, 0xffffffcff7fffL
	};
	static final long[] jjbitVec42 = {
		0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffff07bL, 0x33fffffffff199fL
	};
	static final long[] jjbitVec43 = {
		0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe00ffL, 0x707ffffff0016L
	};
	static final long[] jjbitVec44 = {
		0x7fffffe00000000L, 0xffff03ff003fffffL, 0xffffffffffffffffL, 0x1fff3dff9fefffffL
	};
	static final long[] jjbitVec45 = {
		0xffff1fffffff8000L, 0x7ffL, 0x1ffffffffffffL, 0x0L
	};
	static final long[] jjbitVec46 = {
		0xf3ffffffffffffeeL, 0xffcfff1f3fffL, 0xd3c5fdfffff99feeL, 0xfffcfb080399fL
	};
	static final long[] jjbitVec47 = {
		0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100013bbfL
	};
	static final long[] jjbitVec48 = {
		0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L
	};
	static final long[] jjbitVec49 = {
		0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL
	};
	static final long[] jjbitVec50 = {
		0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x2ffbfffffc7fffecL, 0xc0000ff5f847fL
	};
	static final long[] jjbitVec51 = {
		0x87fffffffffffffeL, 0x3ff7fffL, 0x3bffecaefef02596L, 0x33ff3f5fL
	};
	static final long[] jjbitVec52 = {
		0xc2a003ff03000001L, 0xfffe07fffffffeffL, 0x1ffffffffeff0fdfL, 0x40L
	};
	static final long[] jjbitVec53 = {
		0x3c7f6fbffffffffL, 0x3ff03ffL, 0xffffffff00000000L, 0x7fffffffff003fL
	};
	static final long[] jjbitVec54 = {
		0xffffffff7f3d7fffL, 0x3fe0007ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
	};
	static final long[] jjbitVec55 = {
		0x0L, 0x0L, 0xffffffffffffffffL, 0x3ff080fffffL
	};
	static final long[] jjbitVec56 = {
		0xffffffff03ff7800L, 0xffffffffffffffL, 0x3ffffffffffL, 0x0L
	};
	static final long[] jjbitVec57 = {
		0x80007c000000f000L, 0x8000fc0000000001L, 0xffff00000000L, 0x21fff0000L
	};
	static final long[] jjbitVec58 = {
		0x73efffe000000e0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x7fffffffffffffffL
	};
	static final long[] jjbitVec59 = {
		0x5f7ffdffe0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
	};
	static final long[] jjbitVec60 = {
		0x18000f00000000L, 0xffd702000000e000L, 0xffffffffffffffffL, 0x9fffffffffffffffL
	};
	static final long[] jjbitVec61 = {
		0x87fffffe03ff0010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0xe0000631cfcfcfcL
	};
	private int jjMoveNfa_0(int startState, int curPos)
	{
		int startsAt = 0;
		jjnewStateCnt = 45;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;)
		{
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64)
			{
				long l = 1L << curChar;
				do
				{
					switch(jjstateSet[--i])
					{
					case 3:
						if ((0x3fe000000000000L & l) != 0L)
						{
							if (kind > 14)
								kind = 14;
							jjCheckNAddStates(0, 6);
						}
						else if (curChar == 48)
						{
							if (kind > 14)
								kind = 14;
							jjCheckNAddStates(7, 10);
						}
						else if (curChar == 34)
							jjCheckNAddStates(11, 13);
						else if (curChar == 39)
							jjAddStates(14, 15);
						else if (curChar == 47)
							jjstateSet[jjnewStateCnt++] = 2;
						break;
					case 0:
						if (curChar == 42)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 1:
						if ((0xffff7fffffffffffL & l) != 0L && kind > 7)
							kind = 7;
						break;
					case 2:
						if (curChar == 42)
							jjstateSet[jjnewStateCnt++] = 0;
						break;
					case 4:
						if (curChar == 39)
							jjAddStates(14, 15);
						break;
					case 5:
						if ((0xffffff7fffffdbffL & l) != 0L)
							jjCheckNAdd(6);
						break;
					case 6:
						if (curChar == 39 && kind > 21)
							kind = 21;
						break;
					case 8:
						if ((0x8400000000L & l) != 0L)
							jjCheckNAdd(6);
						break;
					case 9:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(10, 6);
						break;
					case 10:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(6);
						break;
					case 11:
						if ((0xf000000000000L & l) != 0L)
							jjstateSet[jjnewStateCnt++] = 12;
						break;
					case 12:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(10);
						break;
					case 13:
						if (curChar == 34)
							jjCheckNAddStates(11, 13);
						break;
					case 14:
						if ((0xfffffffbffffdbffL & l) != 0L)
							jjCheckNAddStates(11, 13);
						break;
					case 16:
						if ((0x8400000000L & l) != 0L)
							jjCheckNAddStates(11, 13);
						break;
					case 17:
						if (curChar == 34 && kind > 22)
							kind = 22;
						break;
					case 18:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddStates(16, 19);
						break;
					case 19:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddStates(11, 13);
						break;
					case 20:
						if ((0xf000000000000L & l) != 0L)
							jjstateSet[jjnewStateCnt++] = 21;
						break;
					case 21:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(19);
						break;
					case 23:
						if ((0x3ff00000fffc1ffL & l) == 0L)
							break;
						if (kind > 23)
							kind = 23;
						jjstateSet[jjnewStateCnt++] = 23;
						break;
					case 24:
						if (curChar != 48)
							break;
						if (kind > 14)
							kind = 14;
						jjCheckNAddStates(7, 10);
						break;
					case 26:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 15)
							kind = 15;
						jjstateSet[jjnewStateCnt++] = 26;
						break;
					case 28:
						if ((0xff000000000000L & l) == 0L)
							break;
						if (kind > 16)
							kind = 16;
						jjstateSet[jjnewStateCnt++] = 28;
						break;
					case 30:
						if ((0x3000000000000L & l) == 0L)
							break;
						if (kind > 17)
							kind = 17;
						jjstateSet[jjnewStateCnt++] = 30;
						break;
					case 31:
						if (curChar == 46)
							jjCheckNAdd(32);
						break;
					case 32:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 18)
							kind = 18;
						jjCheckNAdd(32);
						break;
					case 33:
						if ((0x3fe000000000000L & l) == 0L)
							break;
						if (kind > 14)
							kind = 14;
						jjCheckNAddStates(0, 6);
						break;
					case 34:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 14)
							kind = 14;
						jjCheckNAdd(34);
						break;
					case 35:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(35, 31);
						break;
					case 36:
						if (curChar == 46)
							jjCheckNAdd(37);
						break;
					case 37:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(37, 38);
						break;
					case 39:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(40);
						break;
					case 40:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 19)
							kind = 19;
						jjCheckNAdd(40);
						break;
					case 41:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(41, 42);
						break;
					case 42:
						if (curChar == 47)
							jjstateSet[jjnewStateCnt++] = 43;
						break;
					case 43:
						if ((0x3fe000000000000L & l) == 0L)
							break;
						if (kind > 20)
							kind = 20;
						jjCheckNAdd(44);
						break;
					case 44:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 20)
							kind = 20;
						jjCheckNAdd(44);
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			else if (curChar < 128)
			{
				long l = 1L << (curChar & 077);
				do
				{
					switch(jjstateSet[--i])
					{
					case 3:
						if ((0x7fffffe87fffffeL & l) == 0L)
							break;
						if (kind > 23)
							kind = 23;
						jjCheckNAdd(23);
						break;
					case 1:
						if (kind > 7)
							kind = 7;
						break;
					case 5:
						if ((0xffffffffefffffffL & l) != 0L)
							jjCheckNAdd(6);
						break;
					case 7:
						if (curChar == 92)
							jjAddStates(20, 22);
						break;
					case 8:
						if ((0x14404410000000L & l) != 0L)
							jjCheckNAdd(6);
						break;
					case 14:
						if ((0xffffffffefffffffL & l) != 0L)
							jjCheckNAddStates(11, 13);
						break;
					case 15:
						if (curChar == 92)
							jjAddStates(23, 25);
						break;
					case 16:
						if ((0x14404410000000L & l) != 0L)
							jjCheckNAddStates(11, 13);
						break;
					case 23:
						if ((0x87fffffe87fffffeL & l) == 0L)
							break;
						if (kind > 23)
							kind = 23;
						jjCheckNAdd(23);
						break;
					case 25:
						if ((0x100000001000000L & l) != 0L)
							jjCheckNAdd(26);
						break;
					case 26:
						if ((0x7e0000007eL & l) == 0L)
							break;
						if (kind > 15)
							kind = 15;
						jjCheckNAdd(26);
						break;
					case 27:
						if ((0x800000008000L & l) == 0L)
							break;
						if (kind > 16)
							kind = 16;
						jjstateSet[jjnewStateCnt++] = 28;
						break;
					case 29:
						if ((0x400000004L & l) == 0L)
							break;
						if (kind > 17)
							kind = 17;
						jjstateSet[jjnewStateCnt++] = 30;
						break;
					case 38:
						if ((0x2000000020L & l) != 0L)
							jjAddStates(26, 27);
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			else
			{
				int hiByte = (int)(curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do
				{
					switch(jjstateSet[--i])
					{
					case 3:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 23)
							kind = 23;
						jjCheckNAdd(23);
						break;
					case 1:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
							kind = 7;
						break;
					case 5:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 6;
						break;
					case 14:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(11, 13);
						break;
					case 23:
						if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 23)
							kind = 23;
						jjCheckNAdd(23);
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			if (kind != 0x7fffffff)
			{
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 45 - (jjnewStateCnt = startsAt)))
				return curPos;
			try { curChar = input_stream.readChar(); }
			catch(java.io.IOException e) { return curPos; }
		}
	}
	private int jjMoveStringLiteralDfa0_3()
	{
		switch(curChar)
		{
		case 42:
			return jjMoveStringLiteralDfa1_3(0x1000L);
		default :
			return 1;
		}
	}
	private int jjMoveStringLiteralDfa1_3(long active0)
	{
		try { curChar = input_stream.readChar(); }
		catch(java.io.IOException e) {
			return 1;
		}
		switch(curChar)
		{
		case 47:
			if ((active0 & 0x1000L) != 0L)
				return jjStopAtPos(1, 12);
			break;
		default :
			return 2;
		}
		return 2;
	}
	private int jjMoveStringLiteralDfa0_1()
	{
		return jjMoveNfa_1(0, 0);
	}
	private int jjMoveNfa_1(int startState, int curPos)
	{
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;)
		{
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64)
			{
				long l = 1L << curChar;
				do
				{
					switch(jjstateSet[--i])
					{
					case 0:
						if ((0x2400L & l) != 0L)
						{
							if (kind > 9)
								kind = 9;
						}
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 1:
						if (curChar == 10 && kind > 9)
							kind = 9;
						break;
					case 2:
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			else if (curChar < 128)
			{
				long l = 1L << (curChar & 077);
				do
				{
					switch(jjstateSet[--i])
					{
					default : break;
					}
				} while(i != startsAt);
			}
			else
			{
				int hiByte = (int)(curChar >> 8);
				int i1 = hiByte >> 6;
			long l1 = 1L << (hiByte & 077);
			int i2 = (curChar & 0xff) >> 6;
			long l2 = 1L << (curChar & 077);
			do
			{
				switch(jjstateSet[--i])
				{
				default : break;
				}
			} while(i != startsAt);
			}
			if (kind != 0x7fffffff)
			{
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
				return curPos;
			try { curChar = input_stream.readChar(); }
			catch(java.io.IOException e) { return curPos; }
		}
	}
	private int jjMoveStringLiteralDfa0_2()
	{
		switch(curChar)
		{
		case 42:
			return jjMoveStringLiteralDfa1_2(0x800L);
		default :
			return 1;
		}
	}
	private int jjMoveStringLiteralDfa1_2(long active0)
	{
		try { curChar = input_stream.readChar(); }
		catch(java.io.IOException e) {
			return 1;
		}
		switch(curChar)
		{
		case 47:
			if ((active0 & 0x800L) != 0L)
				return jjStopAtPos(1, 11);
			break;
		default :
			return 2;
		}
		return 2;
	}
	static final int[] jjnextStates = {
		34, 35, 31, 36, 38, 41, 42, 25, 27, 29, 31, 14, 15, 17, 5, 7, 
		14, 15, 19, 17, 8, 9, 11, 16, 18, 20, 39, 40, 
	};
	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
	{
		switch(hiByte)
		{
		case 0:
			return ((jjbitVec2[i2] & l2) != 0L);
		default :
			if ((jjbitVec0[i1] & l1) != 0L)
				return true;
			return false;
		}
	}
	private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
	{
		switch(hiByte)
		{
		case 0:
			return ((jjbitVec4[i2] & l2) != 0L);
		case 2:
			return ((jjbitVec5[i2] & l2) != 0L);
		case 3:
			return ((jjbitVec6[i2] & l2) != 0L);
		case 4:
			return ((jjbitVec7[i2] & l2) != 0L);
		case 5:
			return ((jjbitVec8[i2] & l2) != 0L);
		case 6:
			return ((jjbitVec9[i2] & l2) != 0L);
		case 7:
			return ((jjbitVec10[i2] & l2) != 0L);
		case 9:
			return ((jjbitVec11[i2] & l2) != 0L);
		case 10:
			return ((jjbitVec12[i2] & l2) != 0L);
		case 11:
			return ((jjbitVec13[i2] & l2) != 0L);
		case 12:
			return ((jjbitVec14[i2] & l2) != 0L);
		case 13:
			return ((jjbitVec15[i2] & l2) != 0L);
		case 14:
			return ((jjbitVec16[i2] & l2) != 0L);
		case 15:
			return ((jjbitVec17[i2] & l2) != 0L);
		case 16:
			return ((jjbitVec18[i2] & l2) != 0L);
		case 17:
			return ((jjbitVec19[i2] & l2) != 0L);
		case 18:
			return ((jjbitVec20[i2] & l2) != 0L);
		case 19:
			return ((jjbitVec21[i2] & l2) != 0L);
		case 20:
			return ((jjbitVec0[i2] & l2) != 0L);
		case 22:
			return ((jjbitVec22[i2] & l2) != 0L);
		case 23:
			return ((jjbitVec23[i2] & l2) != 0L);
		case 24:
			return ((jjbitVec24[i2] & l2) != 0L);
		case 30:
			return ((jjbitVec25[i2] & l2) != 0L);
		case 31:
			return ((jjbitVec26[i2] & l2) != 0L);
		case 32:
			return ((jjbitVec27[i2] & l2) != 0L);
		case 33:
			return ((jjbitVec28[i2] & l2) != 0L);
		case 48:
			return ((jjbitVec29[i2] & l2) != 0L);
		case 49:
			return ((jjbitVec30[i2] & l2) != 0L);
		case 77:
			return ((jjbitVec31[i2] & l2) != 0L);
		case 159:
			return ((jjbitVec32[i2] & l2) != 0L);
		case 164:
			return ((jjbitVec33[i2] & l2) != 0L);
		case 215:
			return ((jjbitVec34[i2] & l2) != 0L);
		case 250:
			return ((jjbitVec35[i2] & l2) != 0L);
		case 251:
			return ((jjbitVec36[i2] & l2) != 0L);
		case 253:
			return ((jjbitVec37[i2] & l2) != 0L);
		case 254:
			return ((jjbitVec38[i2] & l2) != 0L);
		case 255:
			return ((jjbitVec39[i2] & l2) != 0L);
		default :
			if ((jjbitVec3[i1] & l1) != 0L)
				return true;
			return false;
		}
	}
	private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
	{
		switch(hiByte)
		{
		case 0:
			return ((jjbitVec40[i2] & l2) != 0L);
		case 2:
			return ((jjbitVec5[i2] & l2) != 0L);
		case 3:
			return ((jjbitVec41[i2] & l2) != 0L);
		case 4:
			return ((jjbitVec42[i2] & l2) != 0L);
		case 5:
			return ((jjbitVec43[i2] & l2) != 0L);
		case 6:
			return ((jjbitVec44[i2] & l2) != 0L);
		case 7:
			return ((jjbitVec45[i2] & l2) != 0L);
		case 9:
			return ((jjbitVec46[i2] & l2) != 0L);
		case 10:
			return ((jjbitVec47[i2] & l2) != 0L);
		case 11:
			return ((jjbitVec48[i2] & l2) != 0L);
		case 12:
			return ((jjbitVec49[i2] & l2) != 0L);
		case 13:
			return ((jjbitVec50[i2] & l2) != 0L);
		case 14:
			return ((jjbitVec51[i2] & l2) != 0L);
		case 15:
			return ((jjbitVec52[i2] & l2) != 0L);
		case 16:
			return ((jjbitVec53[i2] & l2) != 0L);
		case 17:
			return ((jjbitVec19[i2] & l2) != 0L);
		case 18:
			return ((jjbitVec20[i2] & l2) != 0L);
		case 19:
			return ((jjbitVec54[i2] & l2) != 0L);
		case 20:
			return ((jjbitVec0[i2] & l2) != 0L);
		case 22:
			return ((jjbitVec22[i2] & l2) != 0L);
		case 23:
			return ((jjbitVec55[i2] & l2) != 0L);
		case 24:
			return ((jjbitVec56[i2] & l2) != 0L);
		case 30:
			return ((jjbitVec25[i2] & l2) != 0L);
		case 31:
			return ((jjbitVec26[i2] & l2) != 0L);
		case 32:
			return ((jjbitVec57[i2] & l2) != 0L);
		case 33:
			return ((jjbitVec28[i2] & l2) != 0L);
		case 48:
			return ((jjbitVec58[i2] & l2) != 0L);
		case 49:
			return ((jjbitVec30[i2] & l2) != 0L);
		case 77:
			return ((jjbitVec31[i2] & l2) != 0L);
		case 159:
			return ((jjbitVec32[i2] & l2) != 0L);
		case 164:
			return ((jjbitVec33[i2] & l2) != 0L);
		case 215:
			return ((jjbitVec34[i2] & l2) != 0L);
		case 250:
			return ((jjbitVec35[i2] & l2) != 0L);
		case 251:
			return ((jjbitVec59[i2] & l2) != 0L);
		case 253:
			return ((jjbitVec37[i2] & l2) != 0L);
		case 254:
			return ((jjbitVec60[i2] & l2) != 0L);
		case 255:
			return ((jjbitVec61[i2] & l2) != 0L);
		default :
			if ((jjbitVec3[i1] & l1) != 0L)
				return true;
			return false;
		}
	}

	/** Token literal values. */
	public static final String[] jjstrLiteralImages = {
		"", null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, null, "\50", 
		"\51", "\173", "\175", "\133", "\135", "\73", "\54", "\56", "\100", "\44", "\43", 
		"\75", "\74", "\41", "\176", "\77", "\72", "\53", "\55", "\52", "\57", "\134", "\46", 
		"\174", "\136", "\45", "\76", "\75\75", "\74\75", "\76\75", "\41\75", "\174\174", 
		"\46\46", "\74\74", "\76\76", "\53\76", "\74\53", "\74\76", "\55\76", "\74\55", 
		"\74\41", "\41\76", "\53\75", "\55\75", "\136\75", "\45\75", "\176\75", "\56\56\56", 
		"\75\76", "\44\41", "\43\176", "\72\75", "\72\72", };

	/** Lexer state names. */
	public static final String[] lexStateNames = {
		"DEFAULT",
		"IN_SINGLE_LINE_COMMENT",
		"IN_FORMAL_COMMENT",
		"IN_MULTI_LINE_COMMENT",
	};

	/** Lex State array. */
	public static final int[] jjnewLexState = {
		-1, -1, -1, -1, -1, -1, 1, 2, 3, 0, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
		-1, -1, -1, -1, -1, 
	};
	static final long[] jjtoToken = {
		0xfffffffffcffc001L, 0xffffL, 
	};
	static final long[] jjtoSkip = {
		0x1a3eL, 0x0L, 
	};
	static final long[] jjtoSpecial = {
		0x1a3eL, 0x0L, 
	};
	static final long[] jjtoMore = {
		0x25c0L, 0x0L, 
	};
	protected JavaCharStream input_stream;
	private final int[] jjrounds = new int[45];
	private final int[] jjstateSet = new int[90];
	private final StringBuilder jjimage = new StringBuilder();
	private StringBuilder image = jjimage;
	private int jjimageLen;
	private int lengthOfMatch;
	protected char curChar;
	/** Constructor. */
	public ScriptParserTokenManager(JavaCharStream stream){
		if (JavaCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		input_stream = stream;
	}

	/** Constructor. */
	public ScriptParserTokenManager(JavaCharStream stream, int lexState)throws TokenMgrError{
		this(stream);
		SwitchTo(lexState);
	}

	/** Reinitialise parser. */
	public void ReInit(JavaCharStream stream)
	{
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}
	private void ReInitRounds()
	{
		int i;
		jjround = 0x80000001;
		for (i = 45; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	/** Reinitialise parser. */
	public void ReInit(JavaCharStream stream, int lexState)throws TokenMgrError
	{
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Switch to specified lex state. */
	public void SwitchTo(int lexState) throws TokenMgrError
	{
		if (lexState >= 4 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	protected Token jjFillToken()
	{
		final Token t;
		final String curTokenImage;
		final int beginLine;
		final int endLine;
		final int beginColumn;
		final int endColumn;
		String im = jjstrLiteralImages[jjmatchedKind];
		curTokenImage = (im == null) ? input_stream.GetImage() : im;
		beginLine = input_stream.getBeginLine();
		beginColumn = input_stream.getBeginColumn();
		endLine = input_stream.getEndLine();
		endColumn = input_stream.getEndColumn();
		t = MyToken.newToken(jjmatchedKind, curTokenImage);

		t.beginLine = beginLine;
		t.endLine = endLine;
		t.beginColumn = beginColumn;
		t.endColumn = endColumn;

		return t;
	}

	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;

	/** Get the next Token. */
	public Token getNextToken() throws TokenMgrError
	{
		Token specialToken = null;
		Token matchedToken;
		int curPos = 0;

		EOFLoop :
			for (;;)
			{
				try
				{
					curChar = input_stream.BeginToken();
				}
				catch(java.io.IOException e)
				{
					jjmatchedKind = 0;
					matchedToken = jjFillToken();
					matchedToken.specialToken = specialToken;
					return matchedToken;
				}
				image = jjimage;
				image.setLength(0);
				jjimageLen = 0;

				for (;;)
				{
					switch(curLexState)
					{
					case 0:
						jjmatchedKind = 0x7fffffff;
						jjmatchedPos = 0;
						curPos = jjMoveStringLiteralDfa0_0();
						break;
					case 1:
						jjmatchedKind = 0x7fffffff;
						jjmatchedPos = 0;
						curPos = jjMoveStringLiteralDfa0_1();
						if (jjmatchedPos == 0 && jjmatchedKind > 10)
						{
							jjmatchedKind = 10;
						}
						break;
					case 2:
						jjmatchedKind = 0x7fffffff;
						jjmatchedPos = 0;
						curPos = jjMoveStringLiteralDfa0_2();
						if (jjmatchedPos == 0 && jjmatchedKind > 13)
						{
							jjmatchedKind = 13;
						}
						break;
					case 3:
						jjmatchedKind = 0x7fffffff;
						jjmatchedPos = 0;
						curPos = jjMoveStringLiteralDfa0_3();
						if (jjmatchedPos == 0 && jjmatchedKind > 13)
						{
							jjmatchedKind = 13;
						}
						break;
					}
					if (jjmatchedKind != 0x7fffffff)
					{
						if (jjmatchedPos + 1 < curPos)
							input_stream.backup(curPos - jjmatchedPos - 1);
						if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
						{
							matchedToken = jjFillToken();
							matchedToken.specialToken = specialToken;
							if (jjnewLexState[jjmatchedKind] != -1)
								curLexState = jjnewLexState[jjmatchedKind];
							return matchedToken;
						}
						else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
						{
							if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
							{
								matchedToken = jjFillToken();
								if (specialToken == null)
									specialToken = matchedToken;
								else
								{
									matchedToken.specialToken = specialToken;
									specialToken = (specialToken.next = matchedToken);
								}
								SkipLexicalActions(matchedToken);
							}
							else
								SkipLexicalActions(null);
							if (jjnewLexState[jjmatchedKind] != -1)
								curLexState = jjnewLexState[jjmatchedKind];
							continue EOFLoop;
						}
						MoreLexicalActions();
						if (jjnewLexState[jjmatchedKind] != -1)
							curLexState = jjnewLexState[jjmatchedKind];
						curPos = 0;
						jjmatchedKind = 0x7fffffff;
						try {
							curChar = input_stream.readChar();
							continue;
						}
						catch (java.io.IOException e1) { }
					}
					int error_line = input_stream.getEndLine();
					int error_column = input_stream.getEndColumn();
					String error_after = null;
					boolean EOFSeen = false;
					try { input_stream.readChar(); input_stream.backup(1); }
					catch (java.io.IOException e1) {
						EOFSeen = true;
						error_after = curPos <= 1 ? "" : input_stream.GetImage();
						if (curChar == '\n' || curChar == '\r') {
							error_line++;
							error_column = 0;
						}
						else
							error_column++;
					}
					if (!EOFSeen) {
						input_stream.backup(1);
						error_after = curPos <= 1 ? "" : input_stream.GetImage();
					}
					throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
				}
			}
	}

	void SkipLexicalActions(Token matchedToken)
	{
		switch(jjmatchedKind)
		{
		default :
			break;
		}
	}
	void MoreLexicalActions()
	{
		jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
		switch(jjmatchedKind)
		{
		case 7 :
			image.append(input_stream.GetSuffix(jjimageLen));
			jjimageLen = 0;
			input_stream.backup(1);
			break;
		default :
			break;
		}
	}
	private void jjCheckNAdd(int state)
	{
		if (jjrounds[state] != jjround)
		{
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}
	private void jjAddStates(int start, int end)
	{
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		} while (start++ != end);
	}
	private void jjCheckNAddTwoStates(int state1, int state2)
	{
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	private void jjCheckNAddStates(int start, int end)
	{
		do {
			jjCheckNAdd(jjnextStates[start]);
		} while (start++ != end);
	}

}
